import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
#import getpass
#from itertools import combinations
#import scipy.stats.stats as sss
import yfinance as yf
from datetime import datetime as dt
from dateutil.relativedelta import relativedelta
import time
yf.pdr_override()

def left(s, amount):
    return s[:amount]
def right(s, amount):
    return s[-amount:]
def mid(s, offset, amount):
    return s[offset:offset+amount]

def yearsago(years, from_date=None):
    if from_date is None:
        from_date = dt.today()
    date = from_date - relativedelta(years=years)
    return(dt(date.year,date.month,date.day))

def pesos_aleatorios(n_ativos):
    ma = [np.random.rand() for x in range(n_ativos)]
    soma = sum(ma)
    pa = np.array([ma[x]/soma for x in range(n_ativos)])
    return(pa)
        
class dados_acoes:
    def __init__(self, tickers, inicio=yearsago(2,dt.today()), fim=dt.today()):
        self.tickers = tickers
        self.inicio = inicio
        self.fim = fim
        
    def downloader(self):
        tickers = self.tickers
        inicio = self.inicio
        fim = self.fim
        return(yf.download(tickers,inicio,fim, progress=False))
    
    def retornos(self, coluna='Close', modo='discreto'):
        tickers = self.tickers
        inicio = self.inicio
        fim = self.fim
        self.coluna = coluna
        df_px = dados_acoes(tickers, inicio, fim).downloader()[coluna]
        if modo.lower()=='discreto':
            df_px.Retornos = df_px/df_px.shift(1)-1
        elif modo.lower()=='log':
            df_px.Retornos = np.log(df_px/df_px.shift(1))
        return(df_px.Retornos.dropna())
    
    def retornos_multiplos(self, coluna='Close', modo='discreto'):
        tickers = self.tickers
        inicio = self.inicio
        fim = self.fim
        self.coluna = coluna
        self.modo = modo
        arr_ret = []
        #for i in range(len(tickers)):
        #    arr_ret.append(dados_acoes(tickers[i], inicio, fim).retornos(coluna, modo))
        #return(arr_ret)
        for i in range(len(tickers)):
            df_px = dados_acoes(tickers, inicio, fim).downloader()[coluna][tickers[i].upper()]
            df_px.Retornos = df_px/df_px.shift(1)-1
            arr_ret.append(df_px.Retornos.dropna())
        return(arr_ret)
    
    def vol(self):
        tickers = self.tickers
        vol_arr = dados_acoes(tickers).retornos_multiplos()
        return(np.array([vol_arr[i].std()*np.sqrt(252) for i in range(len(vol_arr))]))
        
    def variancia(self):
        tickers = self.tickers
        var_arr = dados_acoes(tickers).retornos_multiplos()
        return(np.array([(var_arr[i].std()*np.sqrt(252))**2 for i in range(len(var_arr))]))
        
    def esperanca_retornos(self):
        tickers = self.tickers
        retornos_arr = dados_acoes(tickers).retornos_multiplos()
        return(np.array([retornos_arr[i].mean()*252 for i in range(len(retornos_arr))]))
    

        
class markowitz:
    def __init__(self, ret_arr, pesos=None):
        retornos = np.array([ret_arr[i].mean()*252 for i in range(len(ret_arr))])
        self.ret_arr = ret_arr
        self.retornos = retornos
        if pesos is None:
            self.pesos = pesos_aleatorios(len(ret_arr))
        else:
            self.pesos = np.array(pesos)
        
    def matriz_covar(self):
        ret_arr = self.ret_arr
        ret_usado = np.array([ret_arr[i] for i in range(len(ret_arr))])
        return(np.cov(ret_usado)*252)
    
    def retorno(self):
        retornos = self.retornos
        pesos = self.pesos
        return(np.matmul(retornos.T, pesos))
    
    def vol(self):
        pesos = self.pesos
        ret_arr = self.ret_arr
        m_covar = markowitz(ret_arr).matriz_covar()
        return(np.sqrt(np.matmul(np.matmul(pesos,m_covar),pesos.T)))
    
    def variancia(self):
        pesos = self.pesos
        ret_arr = self.ret_arr
        m_covar = markowitz(ret_arr).matriz_covar()
        return(np.matmul(np.matmul(pesos,m_covar),pesos.T))
    
    def portfolios_aleatorios(self, rounds, tickers):
        start_time = time.time()
        dio = 0.044
        ret_arr = self.ret_arr
        retorn_arr, vol_arr, sharpe_arr, pesos_arr = [], [], [], []
        for i in range(rounds):
            obj_mark = markowitz(ret_arr)
            pesos_arr.append(obj_mark.pesos)
            retorn_arr.append(obj_mark.retorno())
            vol_arr.append(obj_mark.vol())
            sharpe_arr.append((retorn_arr[i]-dio)/vol_arr[i])
        sharpe_max = max(sharpe_arr)
        sharpe_max_loc = sharpe_arr.index(sharpe_max)
        vol_sm = vol_arr[sharpe_max_loc]
        ret_sm = retorn_arr[sharpe_max_loc]
        pesos_sm = pesos_arr[sharpe_max_loc]
        plt.clf()
        plt.style.use('seaborn-whitegrid')
        plt.xlabel('Volatilidade')
        plt.ylabel('Retorno')
        grafico = plt.scatter(vol_arr, retorn_arr, c=sharpe_arr, cmap='inferno')
        plt.colorbar(grafico, label='Sharpe')
        plt.scatter(vol_sm, ret_sm,c='red', s=50)
        plt.show()
        elapsed_time = time.time() - start_time
        print('Tempo de execução: ' + str(round(elapsed_time,4)) + 's')
        for x in range(len(pesos_sm)):
            print('Ativo ' + str(tickers[x].upper()) + ': ' + str(round(pesos_sm[x]*100,4)) + '%')
